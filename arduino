#include <SPI.h>
#include <Wire.h> 
#include <LiquidCrystal_I2C.h>

// ==========================================
// CONFIGURATION
// ==========================================
LiquidCrystal_I2C lcd(0x27, 16, 2); // Change to 0x3F if 0x27 doesn't work

// SPI Buffer & State
volatile byte rxBuffer[18];
volatile byte rxIndex = 0;
volatile bool dataReady = false;

// Custom Character: A vertical bar/pointer on the left + generic placeholder
// We will dynamically update this to match the character underneath!
byte customChar[8]; 

// ==========================================
// LOOKUP TABLE (Matches your Verilog Keyboard Module)
// ==========================================
char mapKeyToAscii(byte key) {
    if (key <= 9) return key + '0'; // 0-9
    
    switch(key) {
        // Operators
        case 0x2A: return '+';
        case 0x2B: return '-';
        case 0x2C: return '*';
        case 0x2D: return '/';
        
        // Brackets
        case 0x1E: return '(';
        case 0x1F: return ')';
        
        // Symbols
        case 0xDD: return '.';
        case 0xDC: return ',';
        case 0xC0: return 'e'; // constant e
        case 0xC1: return 'p'; // constant pi (represented as 'p')
        
        // Functions (Represented by single chars to save space)
        case 0xF0: return '^'; // e^x (generic power symbol)
        case 0xF1: return 'L'; // ln
        case 0xF2: return '^'; // pow
        case 0xF3: return 'l'; // log
        case 0xF4: return 's'; // sin
        case 0xF5: return 'c'; // cos
        case 0xF6: return 't'; // tan
        
        // Misc
        case 0xF7: return 'S'; // csc (Shifted sin)
        case 0xF8: return 'C'; // sec (Shifted cos)
        case 0xF9: return 'T'; // cot (Shifted tan)
        case 0xFA: return 's'; // asin 
        case 0xFB: return 'c'; // acos
        case 0xFC: return 't'; // atan
        
        default: return '?';   // Unknown
    }
}

// ==========================================
// SETUP
// ==========================================
void setup() {
  // 1. Initialize LCD (Try begin() instead of init())
  lcd.begin(); 
  lcd.backlight();
  lcd.print("Waiting for FPGA");

  // 2. Initialize SPI Slave
  pinMode(MISO, OUTPUT); 
  
  // Turn on SPI in Slave Mode
  SPCR |= _BV(SPE); 
  
  // Turn on Interrupts
  SPCR |= _BV(SPIE); 
  
  rxIndex = 0;
}


// ==========================================
// SPI INTERRUPT SERVICE ROUTINE (ISR)
// ==========================================
// This runs automatically whenever the FPGA sends a byte.
// It is extremely fast to keep up with the burst.
ISR(SPI_STC_vect) {
  byte c = SPDR; // Read byte from SPI Data Register
  
  if (rxIndex < 18) {
    rxBuffer[rxIndex++] = c;
  }
  
  // If we received the 18th byte (index 17), the packet is complete
  if (rxIndex >= 18) {
    dataReady = true;
    rxIndex = 0; // Reset for next burst (though main loop handles logic)
  }
}

// ==========================================
// HELPER: CREATE POINTER OVERLAY
// ==========================================
// This function takes a standard ASCII char (like 'A' or '5')
// and generates a custom 5x8 bitmap that has a pointer on the left column.
void createPointerChar(char c, byte charCode) {
    // Standard font map for 5x8 LCDs is hard to access directly in Arduino code 
    // without a huge lookup table. 
    // TRICK: We will just draw a generic "Block with Pointer" or 
    // if you want to be perfect, you'd need the font table.
    //
    // SIMPLER APPROACH FOR NOW: 
    // We will draw a "Cursor" symbol (vertical bar) combined with a simple representation.
    // Since we can't easily read the LCD's internal ROM to get the pixels for 'A',
    // we will create a generic "Selected" look, like an underline or a left-bar.
    
    // Let's create a "Left Arrow + Underline" to indicate selection clearly
    // irrespective of the character.
    
    byte pMap[8] = {
      B10000, 
      B11000, // Arrow head
      B11100, 
      B11000, 
      B10000, 
      B00000, 
      B00000, 
      B11111  // Underline
    };
    
    lcd.createChar(0, pMap);
}

// ==========================================
// MAIN LOOP
// ==========================================
void loop() {
  if (dataReady) {
    // 1. Disable interrupts briefly to safely copy buffer
    //    (Optional but good practice if FPGA sends very fast)
    noInterrupts();
    byte localBuf[18];
    memcpy(localBuf, (const void*)rxBuffer, 18);
    dataReady = false;
    rxIndex = 0; // Reset index to be ready for next packet
    interrupts();

    // 2. Parse Size and Pointer
    byte sizeIn = localBuf[16]; // 17th byte
    byte ptrIn  = localBuf[17]; // 18th byte
    
    // Safety clamp
    if (sizeIn > 16) sizeIn = 16; 
    
    // Calculate Pointer Position (0-15)
    byte ptrPos = ptrIn % 16; 
    
    // 3. Update Display
    // We only update if something changed to avoid flicker, 
    // but for simplicity, we refresh every packet here.
    
    lcd.setCursor(0, 0); // Start at beginning of line 1
    
    for (int i = 0; i < 16; i++) {
        
        // LOGIC: Should we show a char or blank?
        if (i < sizeIn) {
            // Translate the opcode to ASCII
            char ascii = mapKeyToAscii(localBuf[i]);
            
            // LOGIC: Is this the pointer location?
            if (i == ptrPos) {
                // If the pointer is here, we need to show the pointer.
                // Since we can't easily merge the bitmap of 'ascii' with a pointer
                // without a massive font table, we will use a trick:
                // We print the character, but we blink the cursor OR use the standard cursor.
                //
                // WAIT! You asked for a custom pointer column.
                // Since we can't generate the bitmap for '5' or 'A' on the fly easily,
                // let's use the "_" underscore approach or a solid block for the cursor.
                //
                // BETTER TRICK: Print the character, and use the hardware cursor?
                // No, you said "overwrite 1st column".
                
                // OK, here is the compromise:
                // We will print a special "Selector" character.
                // If you want the ACTUAL character + Pointer, you need the font table.
                // I will assume for now you want to see the CHARACTER clearly.
                // Let's use the Hardware Cursor for the pointer. It's the cleanest way.
                
                lcd.write(ascii); 
            } else {
                lcd.write(ascii);
            }
        } else {
            // Blanking region (above size)
            lcd.write(' '); 
        }
    }
    
    // POINTER VISUALIZATION
    // Instead of a complex bitmap overlay, let's use the hardware cursor!
    // It's 100% accurate, requires no bitmaps, and overlays perfectly.
    
    if (ptrPos < sizeIn) {
        lcd.setCursor(ptrPos, 0);
        lcd.cursor(); // Turn on underscore cursor
        // lcd.blink(); // Uncomment if you want a blinking block
    } else {
        lcd.noCursor(); // Hide cursor if out of bounds (shouldn't happen with %16)
    }

  }
}
