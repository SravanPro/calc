#include <SPI.h>
#include <Wire.h>
#include <LiquidCrystal_I2C.h>

// ================= CONFIGURATION =================
#define LCD_ADDRESS     0x27 
#define LCD_COLS        16
#define LCD_ROWS        2
#define PACKET_SIZE     24 

// ================= MAPPINGS =================
char mapByteToChar(byte b) {
    if (b >= 0x00 && b <= 0x09) return b + '0'; 
    switch (b) {
        case 0x2A: return '+'; case 0x2B: return '-'; 
        case 0x2C: return '*'; case 0x2D: return '/'; 
        case 0x1E: return '('; case 0x1F: return ')'; 
        case 0xDD: return '.'; case 0xDC: return ','; 
        case 0xC0: return 'e'; case 0xC1: return 0xF7; // pi
        case 0xF0: return 'E'; // Exp
        case 0xF1: return 'N'; // Ln
        case 0xF2: return '^'; 
        case 0xF3: return 'L'; // Log
        case 0xF4: return 'S'; // Sin
        case 0xF5: return 'C'; // Cos
        case 0xF6: return 'T'; // Tan
        case 0xF7: return 'c'; 
        case 0xF8: return 's'; 
        case 0xF9: return 't'; 
        case 0xFA: return 'A'; case 0xFB: return 'B'; case 0xFC: return 'G'; 
        default:   return '?'; 
    }
}

// ================= GLOBALS =================
LiquidCrystal_I2C lcd(LCD_ADDRESS, LCD_COLS, LCD_ROWS);
volatile byte rxBuffer[PACKET_SIZE];
volatile byte rxIndex = 0;
volatile bool packetReady = false;

// ================= SETUP =================
void setup() {
    lcd.begin(); 
    lcd.backlight();
    lcd.setCursor(0, 0);
    lcd.print("Ready...");

    pinMode(MISO, OUTPUT); 
    pinMode(MOSI, INPUT);  
    pinMode(SCK, INPUT);   
    pinMode(SS, INPUT);    // Pin 10

    // SPI Slave Mode
    SPCR |= _BV(SPE) | _BV(SPIE); 

    // Hard Sync Interrupt (Pin 10)
    noInterrupts();
    PCICR |= (1 << PCIE0);    
    PCMSK0 |= (1 << PCINT2);  
    interrupts();
}

// ================= INTERRUPTS =================
ISR (SPI_STC_vect) {
    byte c = SPDR; 
    if (rxIndex < PACKET_SIZE) rxBuffer[rxIndex++] = c;
    if (rxIndex >= PACKET_SIZE) packetReady = true;
}

ISR (PCINT0_vect) {
    if (digitalRead(10) == HIGH) rxIndex = 0; 
}

// ================= HELPER: LONG TO STRING =================
// Custom function to convert 64-bit int to string
// Returns the length of the string
int ullToString(uint64_t value, char* buf) {
    if (value == 0) {
        buf[0] = '0';
        buf[1] = '\0';
        return 1;
    }
    
    int i = 0;
    // Extract digits in reverse
    while (value > 0) {
        buf[i++] = (value % 10) + '0';
        value /= 10;
    }
    buf[i] = '\0';

    // Reverse the string to get correct order
    for (int j = 0; j < i / 2; j++) {
        char temp = buf[j];
        buf[j] = buf[i - 1 - j];
        buf[i - 1 - j] = temp;
    }
    return i;
}

// ================= LOOP =================
unsigned long lastUpdate = 0; 

void loop() {
    if (packetReady && (millis() - lastUpdate > 100)) {
        lastUpdate = millis();
        
        byte localBuf[PACKET_SIZE];
        noInterrupts(); 
        memcpy(localBuf, (const void*)rxBuffer, PACKET_SIZE);
        packetReady = false; 
        interrupts(); 

        // --- ROW 1: INPUT EXPRESSION ---
        lcd.setCursor(0, 0);
        byte sizeVal = localBuf[16];
        for (int i = 0; i < 16; i++) {
            if (i < sizeVal) lcd.print(mapByteToChar(localBuf[i]));
            else lcd.print(" ");
        }

        // --- ROW 2: DECIMAL PARSING ---
        // 1. EXTRACT BITS
        // Byte 18: [JUNK 4] [Sign 1] [Mant 3 (MSB)]
        
        bool signBit = (localBuf[18] >> 1) & 0x01;
        
        // Reconstruct 34-bit Mantissa (using 64-bit storage)
        uint64_t mantissa = 0;
        mantissa |= ((uint64_t)(localBuf[18] & 0x01) << 33); // Top 1 bit
        mantissa |= ((uint64_t)localBuf[19] << 25);
        mantissa |= ((uint64_t)localBuf[20] << 17);
        mantissa |= ((uint64_t)localBuf[21] << 9);
        mantissa |= ((uint64_t)localBuf[22] << 1);
        mantissa |= ((uint64_t)(localBuf[23] >> 7) & 0x01); // Bottom 1 bit from top of Byte 23

        // Extract 7-bit Exponent (Signed)
        int8_t exponent = localBuf[23] & 0x7F;
        // Sign extend 7-bit to 8-bit signed
        if (exponent & 0x40) exponent |= 0x80; 

        // 2. CONVERT TO STRING
        char mantStr[24]; // Buffer for raw digits
        int len = ullToString(mantissa, mantStr);
        
        // Calculate decimal point position
        // Logic: If mantissa is "493..." (len 9) and exp is -7
        // dotPos = 9 + (-7) = 2. Result: "49.3..."
        int dotPos = len + exponent;

        char finalStr[32]; // Buffer for formatted output
        int p = 0;

        // Add Sign
        finalStr[p++] = signBit ? '-' : '+';

        // Add Digits & Decimal Point
        if (dotPos <= 0) {
            // Case: 0.00xxx
            finalStr[p++] = '0';
            finalStr[p++] = '.';
            while (dotPos < 0) {
                finalStr[p++] = '0';
                dotPos++;
            }
            for (int k=0; k<len; k++) finalStr[p++] = mantStr[k];
        } 
        else if (dotPos >= len) {
            // Case: 12300 (Integer with trailing zeros)
            for (int k=0; k<len; k++) finalStr[p++] = mantStr[k];
            while (dotPos > len) {
                finalStr[p++] = '0';
                len++;
            }
        } 
        else {
            // Standard Case: xx.xxx
            for (int k=0; k<len; k++) {
                if (k == dotPos) finalStr[p++] = '.';
                finalStr[p++] = mantStr[k];
            }
        }
        finalStr[p] = '\0'; // Terminate

        // 3. DISPLAY (Truncate to 16 chars)
        lcd.setCursor(0, 1);
        for(int i=0; i<16; i++) {
            if (i < p) lcd.print(finalStr[i]);
            else lcd.print(" ");
        }
    }
}