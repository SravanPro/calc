#include <SPI.h>
#include <Wire.h>
#include <LiquidCrystal_I2C.h>

// ================= CONFIGURATION =================
#define LCD_ADDRESS     0x27 
#define LCD_COLS        16
#define LCD_ROWS        2
#define PACKET_SIZE     24 

// ================= MAPPINGS =================
char mapByteToChar(byte b) {
    if (b >= 0x00 && b <= 0x09) return b + '0'; 
    switch (b) {
        case 0x2A: return '+'; 
        case 0x2B: return '-'; 
        case 0x2C: return '*'; 
        case 0x2D: return '/'; 
        case 0x1E: return '('; 
        case 0x1F: return ')'; 
        case 0xDD: return '.'; 
        case 0xDC: return ','; 
        case 0xC0: return 'e'; 
        case 0xC1: return 0xF7; 
        case 0xF0: return 'E'; 
        case 0xF1: return 'N'; 
        case 0xF2: return '^'; 
        case 0xF3: return 'L'; 
        case 0xF4: return 'S'; 
        case 0xF5: return 'C'; 
        case 0xF6: return 'T'; 
        case 0xF7: return 'c'; 
        case 0xF8: return 's'; 
        case 0xF9: return 't'; 
        case 0xFA: return 'A'; 
        case 0xFB: return 'B'; 
        case 0xFC: return 'G'; 
        default:   return '?'; 
    }
}

// ================= GLOBALS =================
LiquidCrystal_I2C lcd(LCD_ADDRESS, LCD_COLS, LCD_ROWS);
volatile byte rxBuffer[PACKET_SIZE];
volatile byte rxIndex = 0;
volatile bool packetReady = false;

// ================= SETUP =================
void setup() {
    lcd.begin(); 
    lcd.backlight();
    lcd.setCursor(0, 0);
    lcd.print("Syncing...");

    // SPI Pin Setup
    pinMode(MISO, OUTPUT); 
    pinMode(MOSI, INPUT);  
    pinMode(SCK, INPUT);   
    pinMode(SS, INPUT);    // Pin 10

    // 1. Enable SPI in Slave Mode
    SPCR |= _BV(SPE) | _BV(SPIE); 

    // 2. ENABLE "HARD SYNC" INTERRUPT ON PIN 10 (SS)
    noInterrupts();
    PCICR |= (1 << PCIE0);    // Enable Port B Interrupts
    PCMSK0 |= (1 << PCINT2);  // Enable Interrupt for Pin 10
    interrupts();
}

// ================= INTERRUPTS =================

ISR (SPI_STC_vect) {
    byte c = SPDR; 
    if (rxIndex < PACKET_SIZE) {
        rxBuffer[rxIndex++] = c;
    }
    if (rxIndex >= PACKET_SIZE) {
        packetReady = true;
    }
}

ISR (PCINT0_vect) {
    if (digitalRead(10) == HIGH) {
        rxIndex = 0; 
    }
}

// ================= HELPERS =================

// Helper to print "05" instead of "5" to keep the hex string solid
void printTwoDigits(byte val) {
    if (val < 0x10) lcd.print("0");
    lcd.print(val, HEX);
}

// ================= LOOP =================
unsigned long lastUpdate = 0; 

void loop() {
    // Update every 100ms
    if (packetReady && (millis() - lastUpdate > 100)) {
        
        lastUpdate = millis();
        
        // Safely copy data
        byte localBuf[PACKET_SIZE];
        noInterrupts(); 
        memcpy(localBuf, (const void*)rxBuffer, PACKET_SIZE);
        packetReady = false; 
        interrupts(); 

        byte sizeVal = localBuf[16];
        
        // --- ROW 1: MEMORY (User Input) ---
        lcd.setCursor(0, 0);
        for (int i = 0; i < 16; i++) {
            if (i < sizeVal) {
                lcd.print(mapByteToChar(localBuf[i]));
            } else {
                lcd.print(" ");
            }
        }

        // --- ROW 2: 44-BIT ANSWER (11 HEX CHARS) ---
        // Packet indices 18 to 23 hold the 48 bits.
        // localBuf[18] holds the Top 4 bits (Answer) + 4 bits (Junk)
        
        lcd.setCursor(0, 1);
        
        // 1. Print the top nibble (Bits 43-40 of answer)
        // We mask with 0x0F to ignore the top 4 junk bits
        lcd.print(localBuf[18] & 0x0F, HEX); 

        // 2. Print the remaining 5 bytes (Bits 39-0 of answer)
        printTwoDigits(localBuf[19]);
        printTwoDigits(localBuf[20]);
        printTwoDigits(localBuf[21]);
        printTwoDigits(localBuf[22]);
        printTwoDigits(localBuf[23]);
        
        // 3. Clear the rest of the line (we used 11 chars, 5 left)
        lcd.print("     "); 
    }
}